\newcommand{\ghlink}[1]{\href{#1}{#1}}

\chapter{Code repository}\label{ch:repo}
Both mitigations required slight changes to both the Accel-Sim simulator and the GPGPU-Sim version it depends on.
These changes are available in the following repository: \ghlink{https://github.com/jay-tux/accel-sim-cold-start}, and \ghlink{https://github.com/jay-tux/gpgpu-sim-cold-start}.

\section{Memory-only simulation}\label{sec:repo-mem-only}
To enable memory-only simulation, we only modified the \verb|util/tracer_nvbit/tracer_tool/tracer_tool.cu|.
It should be used accordingly to Accel-Sim's original instructions.
However, instead of producing one trace file per kernel, it will produce two.
The first is the original trace file, and the second is a memory-only trace file.

For the \verb|oceanFFT| workload, for example\footnote{In the code examples, we assume that the user is in the root of the repository.}:
\begin{minted}{bash}
$ LD_PRELOAD=./util/tracer_tool/tracer_tool.so /path/to/oceanFFT
Writing results to kernel-1.trace (memory file kernel-mem-1.trace)
Writing results to kernel-2.trace (memory file kernel-mem-2.trace)
Writing results to kernel-3.trace (memory file kernel-mem-3.trace)
Writing results to kernel-4.trace (memory file kernel-mem-4.trace)
Writing results to kernel-5.trace (memory file kernel-mem-5.trace)

$ ./util/tracer_tool/traces-processing/post-traces-processing ./traces/kernelslist
\end{minted}

This will generate thirteen files: five kernel traces, five memory-only kernel traces, two kernel lists (\verb|kernelslist| and \verb|kernelslist.g|), and a \verb|stats.csv| file.
We can now use these traces to create a memory-only simulation.
Say we want to simulate the following process:
\begin{enumerate}
    \item The second kernel, in memory only mode; and
    \item The third kernel, fully (in order to get IPC values for that kernel).
\end{enumerate}

We can now create a new kernel list \verb|kernel3-warmup2.g| containing the following lines:
\begin{minted}[linenos]{text}
kernel-mem-2.traceg
kernel-3.traceg
\end{minted}

If we instruct Accel-Sim to simulate this kernel list, it will simulate the second kernel in memory-only mode and the third kernel fully, allowing us to gather the data we wanted.

\section{Correction factor}\label{sec:repo-corr-fac}
The correction factor requires a slight change in the GPGPU-Sim backend, as well as a set of scripts to automate the process.
We modified GPGPU-Sim to output each L2 cache miss (which results in a DRAM request).
These output lines are always prefixed with \verb|[COLD_START_DRAM_REQ]|.
We also need the modified tracer as used in the previous section (\Cref{sec:repo-mem-only}).

Additionally, we created a set of scripts to extract the actual numbers from the Accel-Sim output.
These scripts live in the \verb|./util/cold_start/| directory.
The scripts rely on a few C++-programs, which can be built using the supplied\space\verb|Makefile|.
The main script is the \verb|./util/cold_start/wrapper.sh| script, which needs the following inputs (in order):
\begin{enumerate}
    \item The Accel-Sim output file\footnote{By default, this output is printed straight to standard output. To use this output, it should be redirected to a file.}; this output should contain the kernel we are interested in.
    \item The path to the memory traces directory, as generated by the tracer tool.
    This directory should contain only two files: the memory trace for the previous kernel and for the current kernel.
    Make sure they are named \verb|kernel-mem-X1.traceg| and \verb|kernel-mem-X2.traceg| (where \verb|X1| and \verb|X2| are consecutive integers).
    \item The GPGPU-Sim configuration file passed to Accel-Sim; this is needed to extract both latencies (DRAM and L2).
    \item Finally, the name of the workload; this is used for the name of the output file.
\end{enumerate}

The script will extract all the required data, and create a file called \verb|<workload>.csv|.

\subsection{Script process}\label{subsec:script-process}
The script runs the following steps:
\begin{enumerate}
    \item Extract kernel names, cycle counts, instruction counts and (cold) IPC values from the output (using the \verb|basics.py| script);
    \item Extract the number of unique DRAM requests from the output (using the \verb|mem_access| program);
    \item Extract the forward reuse factor from the memory traces (using the \verb|reuse| program);
    \item Extract the DRAM and L2 latencies from the GPGPU-Sim configuration file; and finally
    \item Merge all previous outputs together (using the \verb|merge.py| script).
\end{enumerate}